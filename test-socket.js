/**
 * test-socket.js
 *
 * End-to-end Socket.IO tests for the new namespace + Redis-adapter architecture.
 *
 * Scenarios covered
 * ─────────────────
 * 1.  /chat/room  – connection REJECTED with NO token
 * 2.  /chat/dm    – connection REJECTED with NO token
 * 3.  /chat/room  – connection REJECTED with INVALID token
 * 4.  /chat/dm    – connection REJECTED with INVALID token
 * 5.  /chat/room  – connection ACCEPTED with VALID token
 * 6.  /chat/dm    – connection ACCEPTED with VALID token
 * 7.  /chat/room  – joinRoom event → welcome message received
 * 8.  /chat/room  – roomMessage event → message broadcast received
 * 9.  /chat/dm    – joinDmRoom event → success
 * 10. /chat/dm    – dmMessage event → message received
 *
 * Prerequisites
 * ─────────────
 * 1. Server must be running:    npm run dev
 * 2. Generate a test token:     node test-socket-token.js <userId>
 * 3. Paste the token below in TOKEN, and fill in TEST_USER_ID / TEST_ROOM_ID
 *
 * Usage
 * ─────
 *   node test-socket.js
 */

require("dotenv").config();
const { io: socketClient } = require("socket.io-client");

// ─── CONFIGURE BEFORE RUNNING ────────────────────────────────────────────────
const SERVER_URL = process.env.TEST_SERVER_URL || "http://localhost:3000";

// Token generated by:  node test-socket-token.js <userId>
const TOKEN = process.env.TEST_TOKEN || "PASTE_YOUR_TOKEN_HERE";

// A valid room id that exists in your DB (chatMessage.roomId)
const TEST_ROOM_ID = process.env.TEST_ROOM_ID || "test-room-001";

// A valid sender/receiver userId pair
const TEST_SENDER_ID   = process.env.TEST_SENDER_ID   || "USER_ID_1";
const TEST_RECEIVER_ID = process.env.TEST_RECEIVER_ID || "USER_ID_2";

// A DM room id (typically "<smallerId>_<largerId>")
const TEST_DM_ROOM_ID  = process.env.TEST_DM_ROOM_ID  || "dm-test-001";
// ─────────────────────────────────────────────────────────────────────────────

const TIMEOUT_MS = 8000;
let passed = 0;
let failed = 0;

function pass(label) {
  console.log(`  ✅  PASS  ${label}`);
  passed++;
}

function fail(label, reason) {
  console.error(`  ❌  FAIL  ${label}`);
  console.error(`            reason: ${reason}`);
  failed++;
}

/**
 * Returns a promise that resolves with { socket } when connected,
 * or rejects with the connection error string.
 */
function connect(namespace, token) {
  return new Promise((resolve, reject) => {
    const socket = socketClient(`${SERVER_URL}${namespace}`, {
      transports: ["websocket"],
      auth: token ? { token } : {},
      timeout: TIMEOUT_MS,
    });

    const cleanup = () => {
      socket.off("connect");
      socket.off("connect_error");
    };

    socket.once("connect", () => {
      cleanup();
      resolve(socket);
    });

    socket.once("connect_error", (err) => {
      cleanup();
      socket.disconnect();
      reject(err.message || String(err));
    });
  });
}

/**
 * Waits for a specific event on a socket, with a timeout.
 */
function waitForEvent(socket, event, timeoutMs = TIMEOUT_MS) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(
      () => reject(new Error(`Timeout waiting for "${event}"`)),
      timeoutMs
    );
    socket.once(event, (data) => {
      clearTimeout(timer);
      resolve(data);
    });
  });
}

async function runTests() {
  console.log("=".repeat(60));
  console.log(" CareXpert Socket.IO – Namespace + Auth Test Suite");
  console.log(`  Server : ${SERVER_URL}`);
  console.log("=".repeat(60));

  // ── 1 & 2: No token → REJECTED ──────────────────────────────────────────
  console.log("\n[Group 1] Authentication – No token\n");

  for (const ns of ["/chat/room", "/chat/dm"]) {
    try {
      const s = await connect(ns, null);
      s.disconnect();
      fail(`${ns} rejects connection with no token`, "Connected unexpectedly");
    } catch (errMsg) {
      if (errMsg.toLowerCase().includes("authentication")) {
        pass(`${ns} rejects connection with no token  →  "${errMsg}"`);
      } else {
        fail(`${ns} rejects connection with no token`, errMsg);
      }
    }
  }

  // ── 3 & 4: Invalid token → REJECTED ────────────────────────────────────
  console.log("\n[Group 2] Authentication – Invalid token\n");

  const BAD_TOKEN = "invalid.token.here";
  for (const ns of ["/chat/room", "/chat/dm"]) {
    try {
      const s = await connect(ns, BAD_TOKEN);
      s.disconnect();
      fail(`${ns} rejects connection with invalid token`, "Connected unexpectedly");
    } catch (errMsg) {
      if (errMsg.toLowerCase().includes("authentication")) {
        pass(`${ns} rejects connection with invalid token  →  "${errMsg}"`);
      } else {
        fail(`${ns} rejects connection with invalid token`, errMsg);
      }
    }
  }

  // ── 5 & 6: Valid token → ACCEPTED ──────────────────────────────────────
  console.log("\n[Group 3] Authentication – Valid token\n");

  if (TOKEN === "PASTE_YOUR_TOKEN_HERE") {
    console.log(
      "  ⚠️  TOKEN not set. Skipping authenticated tests.\n" +
      "      Run:  node test-socket-token.js <userId>  and paste the token\n" +
      "      at the top of this file or set TEST_TOKEN env var."
    );
    printSummary();
    return;
  }

  let roomSocket, dmSocket;

  try {
    roomSocket = await connect("/chat/room", TOKEN);
    pass(`/chat/room  accepts connection with valid token  (socketId=${roomSocket.id})`);
  } catch (errMsg) {
    fail("/chat/room  accepts connection with valid token", errMsg);
    printSummary();
    return;
  }

  try {
    dmSocket = await connect("/chat/dm", TOKEN);
    pass(`/chat/dm    accepts connection with valid token  (socketId=${dmSocket.id})`);
  } catch (errMsg) {
    fail("/chat/dm    accepts connection with valid token", errMsg);
    roomSocket?.disconnect();
    printSummary();
    return;
  }

  // ── 7: joinRoom + welcome message ───────────────────────────────────────
  console.log("\n[Group 4] /chat/room events\n");

  try {
    const msgPromise = waitForEvent(roomSocket, "message");
    roomSocket.emit("joinRoom", {
      event: "joinRoom",
      data: { userId: TEST_SENDER_ID, username: "TestUser", roomId: TEST_ROOM_ID },
    });
    const msg = await msgPromise;
    if (msg && msg.text) {
      pass(`joinRoom → received welcome message: "${msg.text}"`);
    } else {
      fail("joinRoom → received welcome message", "message payload malformed: " + JSON.stringify(msg));
    }
  } catch (err) {
    fail("joinRoom → received welcome message", err.message);
  }

  // ── 8: roomMessage ──────────────────────────────────────────────────────
  // Open a second room socket so we can receive the broadcast
  let roomSocket2;
  try {
    roomSocket2 = await connect("/chat/room", TOKEN);
    roomSocket2.emit("joinRoom", {
      event: "joinRoom",
      data: { userId: TEST_RECEIVER_ID, username: "TestUser2", roomId: TEST_ROOM_ID },
    });
    await new Promise((r) => setTimeout(r, 500)); // let join settle

    const broadcastPromise = waitForEvent(roomSocket2, "message");
    roomSocket.emit("roomMessage", {
      event: "roomMessage",
      data: {
        senderId: TEST_SENDER_ID,
        username: "TestUser",
        roomId: TEST_ROOM_ID,
        text: "Hello from test script!",
      },
    });

    const msg = await broadcastPromise;
    if (msg && msg.text === "Hello from test script!") {
      pass(`roomMessage → broadcast received on second socket: "${msg.text}"`);
    } else {
      fail("roomMessage → broadcast received", "unexpected payload: " + JSON.stringify(msg));
    }
  } catch (err) {
    fail("roomMessage → broadcast received on second socket", err.message);
  } finally {
    roomSocket2?.disconnect();
  }

  // ── 9: joinDmRoom ───────────────────────────────────────────────────────
  console.log("\n[Group 5] /chat/dm events\n");

  try {
    // joinDmRoom doesn't emit back to the sender — just check no error event
    let errReceived = null;
    dmSocket.once("error", (e) => (errReceived = e));
    dmSocket.emit("joinDmRoom", TEST_DM_ROOM_ID);
    await new Promise((r) => setTimeout(r, 500));

    if (!errReceived) {
      pass(`joinDmRoom "${TEST_DM_ROOM_ID}" → no error`);
    } else {
      fail("joinDmRoom", errReceived);
    }
  } catch (err) {
    fail("joinDmRoom", err.message);
  }

  // ── 10: dmMessage ───────────────────────────────────────────────────────
  let dmSocket2;
  try {
    dmSocket2 = await connect("/chat/dm", TOKEN);
    dmSocket2.emit("joinDmRoom", TEST_DM_ROOM_ID);
    await new Promise((r) => setTimeout(r, 500));

    const dmPromise = waitForEvent(dmSocket2, "message");
    dmSocket.emit("dmMessage", {
      event: "dmMessage",
      data: {
        roomId: TEST_DM_ROOM_ID,
        senderId: TEST_SENDER_ID,
        receiverId: TEST_RECEIVER_ID,
        username: "TestUser",
        text: "DM from test script!",
      },
    });

    const msg = await dmPromise;
    if (msg && msg.text === "DM from test script!") {
      pass(`dmMessage → received on second socket: "${msg.text}"`);
    } else {
      fail("dmMessage → received", "unexpected payload: " + JSON.stringify(msg));
    }
  } catch (err) {
    fail("dmMessage → received on second socket", err.message);
  } finally {
    dmSocket2?.disconnect();
  }

  roomSocket?.disconnect();
  dmSocket?.disconnect();

  printSummary();
}

function printSummary() {
  console.log("\n" + "=".repeat(60));
  console.log(` Results:  ${passed} passed  /  ${failed} failed`);
  console.log("=".repeat(60) + "\n");
  process.exit(failed > 0 ? 1 : 0);
}

runTests().catch((err) => {
  console.error("Unexpected error:", err);
  process.exit(1);
});
